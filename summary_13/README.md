## Практическое занятие №13

### Тема: Работа с классами в JS.

Репозитарий содержит материалы по практическому занятию №13, посвященному работе с классами и ООП.

### Цели занятия
- закрепление знаний, полученных на лекциях;
- практическое применение знаний, полученных на лекциях.

### Задачи занятия
1. Освежаем в памяти классы. Создаем класс для представления сущностей товаров нашего интернет-магазина. Нужно создать класс `Product`, у которого будут приватное свойство `id`, и публичные свойства - наименование, цена, описание. Конструктор класса принимает ИД, наименование, цену и описание. Из методов, у него должен быть метод `getInfo` - он должен возвращать строку вида "Товар Ball, цена 100".
2. Добавляем в класс геттер и сеттер для свойства `id`.
3. Делаем классы `ToolsProduct`, `SportProduct` - для товаров-инструментов и спорттоваров. Товары-инструменты должны иметь публичное свойство `material` (из чего они изготовлены - wood, steel), а спорттовары - свойство `kind`, то есть вид спорта, к которому относятся (footbal, basketbal, ...). Соответственно, эти свойства "заходят" к ним в конструкторы. Оба класса должны по-своему реализовать метод `getInfo`:
 - `SportProduct` должен выводить "Товар Ball для спорта footbal, цена 100"
 - `ToolsProduct` должен выводить "Инструмент Hammer, материал steel, цена 100".
4. Добавляем возможность "уценки" товара. Теперь ВСЕ наши товары должны иметь метод `addDiscount`. Метод должен уменьшать цену товара на 10%.
5. Для товаров класса `SportProduct`, меняем реализацию метода `getInfo` - теперь он должен выводить 2 сообщения. Первое - это сообщение из метода-родителя, а второе - свое.
```
hammer.getInfo();
// Товар Hammer, цена 100
// Инструмент Hammer, материал steel, цена 100
```
То есть, нам нужно вызвать метод родителя.
6. Представим, что мы пишем библиотеку компонентов. Нам нужно реализовать класс `SimplePaginator`, который будет предоставлять возможности пагинации. Пагинация - это разбивка большого кол-ва данных на "страницы". Пример - товары в интернет-магазине, которые показываются по 20 штук. Класс должен принимать в конструкторе:
 - массив с элементами (товарами)
 - количество элементов на странице

И класс должен в конструкторе реализовать такую логику:
 - запомнить в свойство `itemsCount` общее количество элементов
 - посчитать и запомнить в свойстве `pagesCount` количество страниц, которые необходимы для отображения кол-ва товаров
```
const paginator = new SimplePaginator([hammer, ball, shark, saw, drill, shoes, gloves, powerSaw, scissors], 4);
paginator.itemsCount; // 9
paginator.pagesCount; // 3 - потому что на одной странице размещаем 4 товара, соответственно, для отображения 9 товаров нам нужно 3 страницы
```

7. Добавляем функциональности в наш пагинатор. Делаем метод `getProductsForPage(pageNum)` - должен возвращать массив, который содержит те товары, которые должны быть отрендерены на странице `pageNum`. Нумерация страниц - с 0.
```
paginator.getProductsForPage(0); // [hammer, ball, shark, saw]
paginator.getProductsForPage(1); // [drill, shoes, gloves, powerSaw]
paginator.getProductsForPage(2); // [scissors]
```
8. Делаем метод `getPageIndex(itemNum)` - он должен вернуть порядковый номер страницы, на которой показан товар с порядковым номером `itemNum`. Порядковый номер соответствует индексу товара в массиве товаров, который был передан в конструкторе.
```
paginator.getPageIndex(2); // 0 - потому что товар с индексом 2 (shark) размещается на 0-й странице
paginator.getPageIndex(5); // 1 - потому что товар с индексом 5 (shoes) размещается на 1-й странице
```
9. Отвлечемся от темы интернет-магазина, и реализуем класс `VersionsControl`. Он должен реализовать логику работы системы контроля версий. Класс принимает в конструкторе строку с начальной версией программного продукта, и название программного продукта. Строка с начальной версией имеет вид "1.0.0". Первое число - это Major-версия, второе - Minor-версия, и третье - Patch. Нужно сохранить имя программного продукта в поле класса `productName`, а major, minor, patch - в соответствующие ПРИВАТНЫЕ поля. Также реализуем метод `getCurrentVersion`, который должен возвращать строку вида "Software PRODUCT_NAME, release MAJOR.MINOR.PATCH. All rights reserved."
10. Добавляем функциональности. Реализуем методы:
 - `major` - увеличить major на 1, а в minor и patch поставить 0.
 - `minor` - увеличить minor на 1, а в patch поставить 0.
 - `patch` - увеличить patch на 1.
11. Реализуем возможность истории версий. Нам нужно вести историю версий, т.е. при каждом изменении версии (вызове метода major, minor, patch) сохранять текущую версию.
12. Реализуем метод `rollback` - то есть откат к предыдущей версии.


### Полезные ссылки
 - [Классы в JS](https://learn.javascript.ru/classes) - русскоязычный гайд по классам. Рекомендуются к прочтению ВСЕ статьи учебника